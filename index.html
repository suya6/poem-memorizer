<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>å¤è¯—èƒŒè¯µåŠ©æ‰‹ - å…¨å¹³å°å…¼å®¹ç‰ˆ ğŸ¤</title>
  <style>
    body {
      font-family: "Microsoft YaHei", sans-serif;
      padding: 15px;
      background: #f9f7f0;
      line-height: 1.6;
      color: #333;
    }
    select, textarea, button {
      width: 100%;
      padding: 12px;
      margin: 8px 0;
      border: 1px solid #ccc;
      border-radius: 8px;
      box-sizing: border-box;
      font-size: 16px; /* é˜²æ­¢ iOS è‡ªåŠ¨ç¼©æ”¾ */
    }
    #previewArea {
      background: #fff;
      border: 1px dashed #ccc;
      padding: 15px;
      display: none;
      white-space: pre-wrap;
      border-radius: 6px;
    }
    #backgroundPanel {
      display: none;
      margin-top: 20px;
      padding: 15px;
      background: #e8f4fc;
      border-left: 4px solid #3498db;
      border-radius: 6px;
    }
    #startReciteBtn {
      display: none;
      background: #2ecc71;
      color: white;
      font-weight: bold;
      padding: 12px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 16px;
    }

    /* M4 èƒŒè¯µç•Œé¢ */
    #reciteArea {
      display: none;
      margin-top: 20px;
      padding: 20px;
      background: #fff;
      border-radius: 10px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }
    #reciteTitle {
      color: #2c3e50;
      margin-top: 0;
    }
    .toggle-btns {
      margin: 12px 0;
    }
    .toggle-btns button {
      padding: 10px 14px;
      margin-right: 8px;
      margin-bottom: 8px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-weight: bold;
      font-size: 14px;
    }

    .speech-guide {
      background: #e8f5e9;
      padding: 12px;
      border-radius: 8px;
      margin: 10px 0;
      font-size: 14px;
      border-left: 3px solid #4caf50;
    }

    #feedbackArea {
      margin-top: 20px;
      padding: 15px;
      border-radius: 8px;
      background: #f8f9fa;
      border: 1px solid #ddd;
      display: none;
    }
    .highlight-correct { background-color: #d4edda; color: #155724; }
    .highlight-missing { background-color: #f8d7da; text-decoration: line-through; color: #721c24; }
    .highlight-extra { background-color: #fff3cd; color: #856404; }

    .score-bar {
      height: 10px;
      background: #e9ecef;
      border-radius: 5px;
      margin: 5px 0;
      overflow: hidden;
    }
    .score-fill {
      height: 100%;
      border-radius: 5px;
    }
  </style>
</head>
<body>
  <h1>å¤è¯—èƒŒè¯µåŠ©æ‰‹ - å…¨å¹³å°å…¼å®¹ç‰ˆ ğŸ¤</h1>
  <p>é€‰æ‹©ç¯‡ç›® â†’ ç¡®è®¤åŸæ–‡ â†’ å¼€å§‹èƒŒè¯µ â†’ ç”¨<strong>é”®ç›˜ğŸ¤</strong>è¯­éŸ³è¾“å…¥ï¼Œè‡ªåŠ¨è¯„åˆ†ï¼</p>

  <label for="poemSelect">é€‰æ‹©ç¯‡ç›®ï¼š</label>
  <select id="poemSelect">
    <option value="">-- è¯·é€‰æ‹© --</option>
    <option value="æ™‹å¤ªå…ƒä¸­ï¼Œæ­¦é™µäººæ•é±¼ä¸ºä¸šï¼Œç¼˜æºªè¡Œï¼Œå¿˜è·¯ä¹‹è¿œè¿‘ã€‚

å¿½é€¢æ¡ƒèŠ±æ—ï¼Œå¤¹å²¸æ•°ç™¾æ­¥ï¼Œä¸­æ— æ‚æ ‘ï¼ŒèŠ³è‰é²œç¾ï¼Œè½è‹±ç¼¤çº·ã€‚

æ¸”äººç”šå¼‚ä¹‹ï¼Œå¤å‰è¡Œï¼Œæ¬²ç©·å…¶æ—ã€‚

æ—å°½æ°´æºï¼Œä¾¿å¾—ä¸€å±±ï¼Œå±±æœ‰å°å£ï¼Œä»¿ä½›è‹¥æœ‰å…‰ã€‚

ä¾¿èˆèˆ¹ï¼Œä»å£å…¥ã€‚åˆæç‹­ï¼Œæ‰é€šäººã€‚å¤è¡Œæ•°åæ­¥ï¼Œè±ç„¶å¼€æœ—ã€‚">ã€Šæ¡ƒèŠ±æºè®°ã€‹</option>
    
    <option value="å±±ä¸åœ¨é«˜ï¼Œæœ‰ä»™åˆ™åã€‚æ°´ä¸åœ¨æ·±ï¼Œæœ‰é¾™åˆ™çµã€‚

æ–¯æ˜¯é™‹å®¤ï¼ŒæƒŸå¾å¾·é¦¨ã€‚è‹”ç—•ä¸Šé˜¶ç»¿ï¼Œè‰è‰²å…¥å¸˜é’ã€‚

è°ˆç¬‘æœ‰é¸¿å„’ï¼Œå¾€æ¥æ— ç™½ä¸ã€‚å¯ä»¥è°ƒç´ ç´ï¼Œé˜…é‡‘ç»ã€‚

æ— ä¸ç«¹ä¹‹ä¹±è€³ï¼Œæ— æ¡ˆç‰ä¹‹åŠ³å½¢ã€‚å—é˜³è¯¸è‘›åºï¼Œè¥¿èœ€å­äº‘äº­ã€‚">ã€Šé™‹å®¤é“­ã€‹</option>
  </select>

  <label for="manualInput">æˆ–ç²˜è´´åŸæ–‡ï¼š</label>
  <textarea id="manualInput" rows="6" placeholder="è¯·åœ¨æ­¤ç²˜è´´å¸¦æ®µè½ç©ºè¡Œçš„å¤æ–‡å…¨æ–‡..."></textarea>

  <div id="previewArea">
    <strong>é¢„è§ˆåŸæ–‡ï¼š</strong>
    <div id="previewText"></div>
  </div>

  <button id="confirmBtn" disabled>âœ… ç¡®è®¤åŸæ–‡</button>

  <div id="backgroundPanel">
    <h3>ğŸ“œ åˆ›ä½œèƒŒæ™¯</h3>
    <div id="backgroundText"></div>
  </div>

  <button id="startReciteBtn">ğŸ“– å¼€å§‹èƒŒè¯µ</button>

  <!-- M4: èƒŒè¯µç•Œé¢ -->
  <div id="reciteArea">
    <h2 id="reciteTitle">ğŸ“– ç¬¬ <span id="currentIdx">1</span> / <span id="totalSegs">0</span> æ®µ</h2>
    
    <div class="toggle-btns">
      <button id="toggleImage">ğŸ–¼ï¸ æ˜¾ç¤ºé…å›¾</button>
      <button id="toggleTranslation">ğŸ’¬ æ˜¾ç¤ºè¯‘æ–‡</button>
      <button id="toggleKeyPoints">ğŸ’¡ æ˜¾ç¤ºè€ƒç‚¹</button>
    </div>

    <div id="imageContainer" style="display:none; margin:15px 0;"></div>
    <div id="translationContainer" style="display:none; margin:15px 0;"></div>
    <div id="keyPointsContainer" style="display:none;"></div>
    
    <div class="speech-guide">
      ğŸ¤ <strong>å¦‚ä½•è¯­éŸ³è¾“å…¥ï¼Ÿ</strong><br>
      1ï¸âƒ£ ç‚¹å‡»ä¸‹æ–¹è¾“å…¥æ¡† â†’ 2ï¸âƒ£ å¼¹å‡ºé”®ç›˜åç‚¹å‡» <strong>é”®ç›˜ä¸Šçš„ğŸ¤éº¦å…‹é£</strong>ï¼ˆæœç‹—/è®¯é£/ç™¾åº¦ç­‰è¾“å…¥æ³•å‡æœ‰ï¼‰â†’ 3ï¸âƒ£ æœ—è¯»å½“å‰æ®µè½
    </div>
    
    <textarea 
      id="speechInput" 
      rows="4"
      placeholder="ç‚¹æˆ‘ â†’ ç”¨é”®ç›˜ğŸ¤è¯´è¯ â†’ æäº¤è¯„æµ‹"
    ></textarea>
    
    <button id="submitSpeechBtn" style="background:#3498db; color:white;">
      âœ… æäº¤èƒŒè¯µå¹¶è¯„åˆ†
    </button>
    
    <div style="margin-top:15px;">
      <button id="prevBtn" disabled>â¬…ï¸ ä¸Šä¸€æ®µ</button>
      <button id="nextBtn">ä¸‹ä¸€æ®µ â¡ï¸</button>
    </div>

    <!-- è¯­éŸ³åé¦ˆåŒº -->
    <div id="feedbackArea"></div>
  </div>

  <script>
    // === å…¨å±€å˜é‡ ===
    window.yuanwen = "";
    window.m3Data = [];
    let currentSegmentIndex = 0;
    const segmentStates = {};

    // === å·¥å…·å‡½æ•° ===
    function autoSegment(text) {
      return text.split(/\n\s*\n/).map(p => p.trim()).filter(p => p !== '');
    }

    function generatePlaceholderM3Data(segments) {
      return segments.map((originalText, index) => ({
        originalText,
        image: `https://picsum.photos/400/200?random=${index+1}`,
        translation: `ç¬¬${index+1}æ®µç°ä»£ç¿»è¯‘ï¼šæ­¤å¤„å¯æ›¿æ¢ä¸ºçœŸå®è¯‘æ–‡...`,
        keyPoints: `â€¢ è€ƒç‚¹å ä½\nâ€¢ ç¬¬${index+1}æ®µ`
      }));
    }

    // === é«˜çº§æ¯”å¯¹å¼•æ“ ===
    function advancedCompare(spoken, original) {
      const cleanSpoken = spoken.replace(/[ï¼Œã€‚ï¼Ÿï¼ï¼›ï¼šâ€œâ€â€˜â€™\s]/g, '');
      const cleanOriginal = original.replace(/[ï¼Œã€‚ï¼Ÿï¼ï¼›ï¼šâ€œâ€â€˜â€™\s]/g, '');

      // å‡†ç¡®ç‡
      const editDist = levenshteinDistance(cleanSpoken, cleanOriginal);
      const maxLength = Math.max(cleanSpoken.length, cleanOriginal.length);
      const accuracy = maxLength > 0 ? Math.max(0, 100 - Math.round((editDist / maxLength) * 100)) : 0;

      // å®Œæ•´åº¦
      const originalWords = cleanOriginal.split('');
      const spokenSet = new Set(cleanSpoken.split(''));
      const covered = originalWords.filter(w => spokenSet.has(w)).length;
      const completeness = originalWords.length > 0 ? Math.round((covered / originalWords.length) * 100) : 0;

      // æµç•…åº¦ï¼ˆæ¨¡æ‹Ÿï¼‰
      const fluency = spoken.length > 5 ? Math.min(100, 80 + Math.random() * 20) : 50;

      // é«˜äº®å·®å¼‚
      const highlighted = highlightDifferences(spoken, original);

      return { accuracy, completeness, fluency, highlighted };
    }

    function levenshteinDistance(a, b) {
      if (a.length === 0) return b.length;
      if (b.length === 0) return a.length;
      const matrix = Array(b.length + 1).fill().map((_, i) => [i]);
      for (let j = 0; j <= a.length; j++) matrix[0][j] = j;
      for (let i = 1; i <= b.length; i++) {
        for (let j = 1; j <= a.length; j++) {
          const cost = b[i-1] === a[j-1] ? 0 : 1;
          matrix[i][j] = Math.min(matrix[i-1][j] + 1, matrix[i][j-1] + 1, matrix[i-1][j-1] + cost);
        }
      }
      return matrix[b.length][a.length];
    }

    function highlightDifferences(spoken, original) {
      const cleanSpoken = spoken.replace(/[ï¼Œã€‚ï¼Ÿï¼ï¼›ï¼šâ€œâ€â€˜â€™\s]/g, '');
      const cleanOriginal = original.replace(/[ï¼Œã€‚ï¼Ÿï¼ï¼›ï¼šâ€œâ€â€˜â€™\s]/g, '');
      
      let result = '';
      let i = 0, j = 0;
      
      while (i < cleanSpoken.length || j < cleanOriginal.length) {
        if (i < cleanSpoken.length && j < cleanOriginal.length && cleanSpoken[i] === cleanOriginal[j]) {
          result += `<span class="highlight-correct">${cleanSpoken[i]}</span>`;
          i++; j++;
        } else if (i < cleanSpoken.length && (j >= cleanOriginal.length || !cleanOriginal.includes(cleanSpoken[i]))) {
          result += `<span class="highlight-extra">${cleanSpoken[i]}</span>`;
          i++;
        } else {
          result += `<span class="highlight-missing">${cleanOriginal[j]}</span>`;
          j++;
        }
      }
      return result || 'ï¼ˆæ— å†…å®¹ï¼‰';
    }

    function getColorByScore(score) {
      if (score >= 90) return '#27ae60';
      if (score >= 70) return '#f39c12';
      return '#e74c3c';
    }

    function renderFeedback(result, spoken) {
      const { accuracy, completeness, fluency, highlighted } = result;
      const avg = Math.round((accuracy + completeness + fluency) / 3);

      let comment = "";
      if (avg >= 90) comment = "ğŸŒŸ èƒŒå¾—å®Œç¾ï¼ä½ å°±æ˜¯å¤æ–‡å°è¾¾äººï¼";
      else if (avg >= 75) comment = "ğŸ‘ å¾ˆæ£’ï¼æ³¨æ„å‡ ä¸ªå­—å°±æ»¡åˆ†å•¦ï½";
      else if (avg >= 60) comment = "ğŸ’¡ æœ‰è¿›æ­¥ï¼å†è¯»ä¸¤éä¼šæ›´å¥½";
      else comment = "ğŸŒ± åˆ«ç°å¿ƒï¼Œå¤šå¬å¤šè¯»ï¼Œä½ ä¸€å®šè¡Œï¼";

      const feedbackHTML = `
        <h3>ğŸ“Š èƒŒè¯µè¯„æµ‹æŠ¥å‘Š</h3>
        <p><strong>ä½ è¯´çš„æ˜¯ï¼š</strong>${spoken}</p>
        <p><strong>åŸæ–‡å¯¹æ¯”ï¼š</strong></p>
        <div style="font-family:monospace; padding:8px; background:#eee; border-radius:4px;">${highlighted}</div>
        
        <div style="margin:15px 0;">
          <div>âœ… å‡†ç¡®ç‡: ${accuracy}%</div>
          <div class="score-bar"><div class="score-fill" style="width:${accuracy}%; background:${getColorByScore(accuracy)}"></div></div>
          
          <div>ğŸ“š å®Œæ•´åº¦: ${completeness}%</div>
          <div class="score-bar"><div class="score-fill" style="width:${completeness}%; background:${getColorByScore(completeness)}"></div></div>
          
          <div>ğŸ—£ï¸ æµç•…åº¦: ${fluency.toFixed(0)}%</div>
          <div class="score-bar"><div class="score-fill" style="width:${fluency}%; background:${getColorByScore(fluency)}"></div></div>
        </div>
        
        <p><strong>ç»¼åˆè¯„åˆ†: ${avg}åˆ†</strong></p>
        <p style="font-weight:bold; color:${avg>=80?'#27ae60':avg>=60?'#f39c12':'#e74c3c'}">${comment}</p>
      `;

      const el = document.getElementById('feedbackArea');
      el.innerHTML = feedbackHTML;
      el.style.display = 'block';
    }

    // === ä¸»æµç¨‹ ===
    function updatePreview() {
      const selectVal = document.getElementById('poemSelect').value;
      const manualVal = document.getElementById('manualInput').value.trim();
      const previewArea = document.getElementById('previewArea');
      const previewText = document.getElementById('previewText');
      const confirmBtn = document.getElementById('confirmBtn');

      let textToShow = manualVal || selectVal;
      if (textToShow) {
        previewText.textContent = textToShow;
        previewArea.style.display = 'block';
        confirmBtn.disabled = false;
      } else {
        previewArea.style.display = 'none';
        confirmBtn.disabled = true;
      }
    }

    function confirmYuanwen() {
      const selectEl = document.getElementById('poemSelect');
      const title = selectEl.options[selectEl.selectedIndex].text;
      const finalText = document.getElementById('manualInput').value.trim() || selectEl.value;

      if (!finalText) return alert("è¯·å…ˆé€‰æ‹©æˆ–è¾“å…¥å¤æ–‡ï¼");
      
      window.yuanwen = finalText;
      const segments = autoSegment(finalText);
      window.m3Data = generatePlaceholderM3Data(segments);
      
      document.getElementById('backgroundText').textContent = `ã€åˆ›ä½œèƒŒæ™¯å ä½ã€‘\næ­£åœ¨å­¦ä¹ ï¼š${title}`;
      document.getElementById('backgroundPanel').style.display = 'block';
      document.getElementById('startReciteBtn').style.display = 'block';
    }

    function renderReciteInterface() {
      // éšè—å‰ç½®ç•Œé¢
      ['poemSelect', 'manualInput', 'previewArea', 'confirmBtn', 'backgroundPanel', 'startReciteBtn']
        .forEach(id => document.getElementById(id).style.display = 'none');
      document.querySelector('label[for="manualInput"]').style.display = 'none';

      document.getElementById('reciteArea').style.display = 'block';
      currentSegmentIndex = 0;
      updateReciteSegment();
    }

    function updateReciteSegment() {
      const data = window.m3Data[currentSegmentIndex];
      const total = window.m3Data.length;
      document.getElementById('currentIdx').textContent = currentSegmentIndex + 1;
      document.getElementById('totalSegs').textContent = total;

      if (!segmentStates[currentSegmentIndex]) {
        segmentStates[currentSegmentIndex] = { image: false, translation: false, keyPoints: false };
      }
      const state = segmentStates[currentSegmentIndex];

      document.getElementById('imageContainer').innerHTML = `
        <img src="${data.image}" style="width:100%; max-width:400px; height:auto; border-radius:8px;" 
             onerror="this.parentElement.innerHTML='<p style=\"color:#e74c3c;\">âš ï¸ å›¾ç‰‡åŠ è½½å¤±è´¥</p>';">`;
      document.getElementById('translationContainer').innerHTML = `<p>${data.translation}</p>`;
      document.getElementById('keyPointsContainer').innerHTML = `<pre>${data.keyPoints}</pre>`;

      ['image', 'translation', 'keyPoints'].forEach(key => {
        const el = document.getElementById(`${key}Container`);
        el.style.display = state[key] ? 'block' : 'none';
        document.getElementById(`toggle${key.charAt(0).toUpperCase() + key.slice(1)}`).textContent = 
          state[key] ? `éšè—${['é…å›¾','è¯‘æ–‡','è€ƒç‚¹'][['image','translation','keyPoints'].indexOf(key)]}` 
                     : `æ˜¾ç¤º${['é…å›¾','è¯‘æ–‡','è€ƒç‚¹'][['image','translation','keyPoints'].indexOf(key)]}`;
      });

      document.getElementById('prevBtn').disabled = currentSegmentIndex === 0;
      document.getElementById('nextBtn').disabled = currentSegmentIndex === total - 1;
      document.getElementById('feedbackArea').style.display = 'none';
      document.getElementById('speechInput').value = ''; // æ¸…ç©ºè¾“å…¥æ¡†
    }

    // === äº‹ä»¶ç»‘å®š ===
    document.getElementById('poemSelect').addEventListener('change', updatePreview);
    document.getElementById('manualInput').addEventListener('input', updatePreview);
    document.getElementById('confirmBtn').addEventListener('click', confirmYuanwen);
    document.getElementById('startReciteBtn').addEventListener('click', renderReciteInterface);
    document.getElementById('prevBtn').addEventListener('click', () => {
      if (currentSegmentIndex > 0) {
        currentSegmentIndex--;
        updateReciteSegment();
      }
    });
    document.getElementById('nextBtn').addEventListener('click', () => {
      if (currentSegmentIndex < window.m3Data.length - 1) {
        currentSegmentIndex++;
        updateReciteSegment();
      }
    });
    ['Image', 'Translation', 'KeyPoints'].forEach(name => {
      document.getElementById(`toggle${name}`).addEventListener('click', () => {
        const key = name.toLowerCase();
        segmentStates[currentSegmentIndex][key] = !segmentStates[currentSegmentIndex][key];
        updateReciteSegment();
      });
    });
    document.getElementById('submitSpeechBtn').addEventListener('click', () => {
      const spoken = document.getElementById('speechInput').value.trim();
      if (!spoken) {
        alert("è¯·å…ˆé€šè¿‡é”®ç›˜ğŸ¤è¾“å…¥èƒŒè¯µå†…å®¹ï¼");
        return;
      }
      const original = window.m3Data[currentSegmentIndex].originalText;
      const result = advancedCompare(spoken, original);
      renderFeedback(result, spoken);
    });
  </script>
</body>
</html>