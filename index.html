<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <!-- ç¦ç”¨ç¼“å­˜ -->
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">
  <title>å¤è¯—èƒŒè¯µåŠ©æ‰‹ - ä¸­å°å­¦ç‰ˆ ğŸŒ¸</title>
  <style>
    body {
      font-family: "Microsoft YaHei", sans-serif;
      padding: 15px;
      background-size: cover;
      background-position: center;
      background-repeat: no-repeat;
      background-attachment: fixed;
      line-height: 1.6;
      color: #333;
      margin: 0;
      min-height: 100vh;
    }
    select, textarea, button {
      width: 100%;
      padding: 12px;
      margin: 8px 0;
      border: 1px solid #ccc;
      border-radius: 8px;
      box-sizing: border-box;
      font-size: 16px;
    }
    #previewArea {
      background: rgba(255, 255, 255, 0.9);
      border: 1px dashed #ccc;
      padding: 15px;
      display: none;
      white-space: pre-wrap;
      border-radius: 6px;
    }
    #backgroundPanel {
      display: none;
      margin-top: 20px;
      padding: 15px;
      background: rgba(232, 244, 252, 0.9);
      border-left: 4px solid #3498db;
      border-radius: 6px;
    }
    #startReciteBtn {
      display: none;
      background: #2ecc71;
      color: white;
      font-weight: bold;
      padding: 12px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 16px;
    }

    /* M4: èƒŒè¯µç•Œé¢ */
    #reciteArea {
      display: none;
      margin-top: 20px;
      padding: 20px;
      background: rgba(255, 255, 255, 0.92);
      border-radius: 10px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.15);
      position: relative;
      z-index: 10;
    }
    #reciteHeader {
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 10px;
      margin-bottom: 12px;
    }
    #reciteTitle {
      color: #2c3e50;
      margin: 0;
      font-size: 1.2em;
    }

    /* âœ… ä¿®å¤ï¼šå¸¦çŠ¶æ€åé¦ˆçš„å•é€‰åœ†ç‚¹ */
    .options-row {
      display: flex;
      gap: 16px;
      align-items: center;
      font-size: 0.9em;
    }
    .radio-option {
      display: flex;
      align-items: center;
      gap: 6px;
      cursor: pointer;
    }
    input[type="radio"] {
      display: none;
    }
    .radio-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      border: 2px solid #e74c3c;
      background: transparent;
      transition: background 0.2s ease;
    }
    input[type="radio"]:checked + .radio-dot {
      background: #e74c3c;
    }

    .speech-guide {
      background: #e8f5e9;
      padding: 12px;
      border-radius: 8px;
      margin: 10px 0;
      font-size: 14px;
      border-left: 3px solid #4caf50;
    }

    #feedbackArea {
      margin-top: 20px;
      padding: 15px;
      border-radius: 8px;
      background: #f8f9fa;
      border: 1px solid #ddd;
      display: none;
    }
    .highlight-correct { background-color: #d4edda; color: #155724; }
    .highlight-missing { background-color: #f8d7da; text-decoration: line-through; color: #721c24; }
    .highlight-extra { background-color: #fff3cd; color: #856404; }

    .score-bar {
      height: 10px;
      background: #e9ecef;
      border-radius: 5px;
      margin: 5px 0;
      overflow: hidden;
    }
    .score-fill {
      height: 100%;
      border-radius: 5px;
    }

    #actionButtons {
      display: flex;
      gap: 10px;
      margin-top: 20px;
    }
    #actionButtons button {
      flex: 1;
      min-height: 44px;
    }
  </style>
</head>
<body>
  <!-- M0: å¯åŠ¨é¡µ -->
  <h1>å¤è¯—èƒŒè¯µåŠ©æ‰‹ - ä¸­å°å­¦ç‰ˆ ğŸŒ¸</h1>
  <p>é€‰ç¯‡ç›® â†’ çœ‹åŸæ–‡ â†’ åˆ†æ®µèƒŒ â†’ ç”¨<strong>é”®ç›˜ğŸ¤</strong>è¯­éŸ³è¾“å…¥ï¼ŒAI è‡ªåŠ¨æ‰“åˆ†ï¼</p>

  <!-- M1: è¾“å…¥æ¨¡å— -->
  <label for="poemSelect">ğŸ“š é€‰æ‹©ç¯‡ç›®ï¼š</label>
  <select id="poemSelect">
    <option value="">-- è¯·é€‰æ‹© --</option>
    <option value="æ™‹å¤ªå…ƒä¸­ï¼Œæ­¦é™µäººæ•é±¼ä¸ºä¸šï¼Œç¼˜æºªè¡Œï¼Œå¿˜è·¯ä¹‹è¿œè¿‘ã€‚

å¿½é€¢æ¡ƒèŠ±æ—ï¼Œå¤¹å²¸æ•°ç™¾æ­¥ï¼Œä¸­æ— æ‚æ ‘ï¼ŒèŠ³è‰é²œç¾ï¼Œè½è‹±ç¼¤çº·ã€‚

æ¸”äººç”šå¼‚ä¹‹ï¼Œå¤å‰è¡Œï¼Œæ¬²ç©·å…¶æ—ã€‚

æ—å°½æ°´æºï¼Œä¾¿å¾—ä¸€å±±ï¼Œå±±æœ‰å°å£ï¼Œä»¿ä½›è‹¥æœ‰å…‰ã€‚

ä¾¿èˆèˆ¹ï¼Œä»å£å…¥ã€‚åˆæç‹­ï¼Œæ‰é€šäººã€‚å¤è¡Œæ•°åæ­¥ï¼Œè±ç„¶å¼€æœ—ã€‚">ã€Šæ¡ƒèŠ±æºè®°ã€‹èŠ‚é€‰</option>
    
    <option value="å±±ä¸åœ¨é«˜ï¼Œæœ‰ä»™åˆ™åã€‚æ°´ä¸åœ¨æ·±ï¼Œæœ‰é¾™åˆ™çµã€‚

æ–¯æ˜¯é™‹å®¤ï¼ŒæƒŸå¾å¾·é¦¨ã€‚è‹”ç—•ä¸Šé˜¶ç»¿ï¼Œè‰è‰²å…¥å¸˜é’ã€‚

è°ˆç¬‘æœ‰é¸¿å„’ï¼Œå¾€æ¥æ— ç™½ä¸ã€‚å¯ä»¥è°ƒç´ ç´ï¼Œé˜…é‡‘ç»ã€‚

æ— ä¸ç«¹ä¹‹ä¹±è€³ï¼Œæ— æ¡ˆç‰ä¹‹åŠ³å½¢ã€‚å—é˜³è¯¸è‘›åºï¼Œè¥¿èœ€å­äº‘äº­ã€‚">ã€Šé™‹å®¤é“­ã€‹</option>
  </select>

  <label for="manualInput">âœï¸ æˆ–ç²˜è´´åŸæ–‡ï¼š</label>
  <textarea id="manualInput" rows="6" placeholder="è¯·åœ¨æ­¤ç²˜è´´å¸¦æ®µè½ç©ºè¡Œçš„å¤æ–‡å…¨æ–‡..."></textarea>

  <!-- M2: é¢„è§ˆç¡®è®¤æ¨¡å— -->
  <div id="previewArea">
    <strong>ğŸ” é¢„è§ˆåŸæ–‡ï¼š</strong>
    <div id="previewText"></div>
  </div>
  <button id="confirmBtn" disabled>âœ… ç¡®è®¤åŸæ–‡</button>

  <!-- M3: èƒŒæ™¯ä¿¡æ¯æ¨¡å— -->
  <div id="backgroundPanel">
    <h3>ğŸ“œ åˆ›ä½œèƒŒæ™¯</h3>
    <div id="backgroundText"></div>
  </div>
  <button id="startReciteBtn">ğŸ“– å¼€å§‹èƒŒè¯µ</button>

  <!-- M4: èƒŒè¯µè¯„æµ‹æ¨¡å— -->
  <div id="reciteArea">
    <div id="reciteHeader">
      <div id="reciteTitle">ğŸ“– ç¬¬ <span id="currentIdx">1</span> / <span id="totalSegs">0</span> æ®µ</div>
      <div class="options-row">
        <label class="radio-option">
          <input type="radio" name="viewMode" value="translation">
          <span class="radio-dot"></span>
          <span>è¯‘æ–‡</span>
        </label>
        <label class="radio-option">
          <input type="radio" name="viewMode" value="keyPoints">
          <span class="radio-dot"></span>
          <span>è€ƒç‚¹</span>
        </label>
      </div>
    </div>

    <div id="contentContainer"></div>
    
    <div class="speech-guide">
      ğŸ¤ <strong>æ€ä¹ˆç”¨è¯­éŸ³è¾“å…¥ï¼Ÿ</strong><br>
      1ï¸âƒ£ ç‚¹ä¸‹æ–¹è¾“å…¥æ¡† â†’ 2ï¸âƒ£ å¼¹å‡ºé”®ç›˜åç‚¹ <strong>ğŸ¤éº¦å…‹é£</strong>ï¼ˆæœç‹—/è®¯é£éƒ½æœ‰ï¼‰â†’ 3ï¸âƒ£ å¤§å£°è¯»å½“å‰æ®µè½ï¼
    </div>
    
    <textarea 
      id="speechInput" 
      rows="4"
      placeholder="ç‚¹æˆ‘ â†’ ç”¨é”®ç›˜ğŸ¤è¯´è¯ â†’ æäº¤è¯„æµ‹"
    ></textarea>
    
    <button id="submitSpeechBtn" style="background:#3498db; color:white;">
      âœ… æäº¤èƒŒè¯µå¹¶è¯„åˆ†
    </button>
    
    <div id="feedbackArea"></div>

    <div id="actionButtons">
      <button id="prevBtn" disabled>â¬…ï¸ ä¸Šä¸€æ®µ</button>
      <button id="nextBtn">ä¸‹ä¸€æ®µ â¡ï¸</button>
      <button id="retryBtn" style="background:#f39c12; color:white; display:none;">ğŸ” é‡æµ‹æœ¬æ®µ</button>
    </div>
  </div>

  <script>
    // === å…¨å±€å˜é‡ ===
    window.yuanwen = "";
    window.m3Data = [];
    let currentSegmentIndex = 0;
    const segmentStates = {};

    // === å·¥å…·å‡½æ•° ===
    function autoSegment(text) {
      return text.split(/\n\s*\n/).map(p => p.trim()).filter(p => p !== '');
    }

    // âœ… æ›´æ–°ï¼šä¸­å°å­¦ç”Ÿå‹å¥½è¯‘æ–‡ + æ ‡å‡†åŒ–è€ƒç‚¹
    function generatePlaceholderM3Data(segments) {
      return segments.map((originalText, index) => {
        const n = index + 1;

        const translations = [
          "æ¸”äººå°å“¥åˆ’èˆ¹è¿·è·¯ï¼Œçªç„¶é—¯è¿›ä¸€ç‰‡ç»ç¾æ¡ƒèŠ±æ—ï¼ç²‰çº¢èŠ±ç“£é£˜æ»¡åœ°ï½ğŸŒ¸",
          "ç©¿è¿‡å±±æ´ï¼Œçœ¼å‰ç«Ÿæ˜¯ä¸€ä¸ªä¸ä¸–éš”ç»çš„ä¹Œæ‰˜é‚¦ï¼æ²¡æœ‰ä½œä¸šï¼Œæ²¡æœ‰è€ƒè¯•ï¼Œåªæœ‰å¿«ä¹æ‘æ°‘ï½ğŸ˜",
          "å±±ä¸ç”¨é«˜ï¼Œæœ‰ä»™å°±çµï¼›æˆ¿ä¸ç”¨è±ªï¼Œæœ‰å¾·å°±é¦™ï½é™‹å®¤ä¹Ÿèƒ½å˜ç½‘çº¢æ‰“å¡åœ°ï¼ğŸ ğŸ’«",
          "è°ˆç¬‘å…¨æ˜¯å­¦éœ¸ï¼Œæ¥å¾€æ²¡æœ‰å­¦æ¸£ï¼å¼¹ç´è¯»ä¹¦ï¼Œè¿œç¦»å†…å·ï¼Œè¿™æ‰æ˜¯ç†æƒ³ç”Ÿæ´»å•Šï½ğŸ“šğŸ§˜"
        ];

        const keyPointsList = [
          `ã€å­—è¯ã€‘ç¼˜ï¼šæ²¿ç€ã€é¡ºç€\nã€å­—è¯ã€‘é²œç¾ï¼šé²œè‰³ç¾ä¸½ï¼ˆä¸æ˜¯å¥½åƒï¼ï¼‰\nã€å­—è¯ã€‘è½è‹±ï¼šè½èŠ±\nã€æ–‡åŒ–ã€‘â€œèŠ³è‰é²œç¾ï¼Œè½è‹±ç¼¤çº·â€ï¼šç»å…¸æ™¯ç‰©æå†™ï¼Œå¸¸è€ƒèµæ`,
          `ã€å­—è¯ã€‘å¦»å­ï¼šå¦»å­å’Œå­©å­\nã€å­—è¯ã€‘ç»å¢ƒï¼šä¸ä¸–éš”ç»çš„åœ°æ–¹\nã€å¥å¼ã€‘â€œä¸è¶³ä¸ºå¤–äººé“ä¹Ÿâ€ï¼šçœç•¥å¥ï¼Œ(æ¡ƒèŠ±æºäºº) ä¸å€¼å¾—å¯¹å¤–äººè¯´\nã€æ–‡åŒ–ã€‘â€œä¸–å¤–æ¡ƒæºâ€æˆè¯­å‡ºå¤„`,
          `ã€å¥å¼ã€‘â€œâ€¦â€¦è€…ï¼Œâ€¦â€¦ä¹Ÿâ€ï¼šåˆ¤æ–­å¥ï¼Œå¦‚â€œæ–¯æ˜¯é™‹å®¤â€=â€œè¿™æ˜¯ä¸€é—´é™‹å®¤â€\nã€è™šè¯ã€‘â€œä¹‹â€ï¼šå–æ¶ˆå¥å­ç‹¬ç«‹æ€§ï¼Œæ— å®ä¹‰\nã€æ–‡åŒ–ã€‘â€œå—é˜³è¯¸è‘›åºï¼Œè¥¿èœ€å­äº‘äº­â€ï¼šç”¨åäººæ•…å±…ç±»æ¯”ï¼ŒæŠ¬é«˜è‡ªå·±`,
          `ã€å­—è¯ã€‘é¸¿å„’ï¼šå¤§å­¦é—®å®¶\nã€å­—è¯ã€‘ç™½ä¸ï¼šå¹³æ°‘ï¼Œæ²¡åŠŸåçš„äºº\nã€å¥å¼ã€‘â€œå¯ä»¥â€¦â€¦â€ï¼šçœç•¥ä¸»è¯­â€œå¾â€ï¼Œæˆ‘èƒ½â€¦â€¦`
        ];

        return {
          originalText,
          image: `https://picsum.photos/800/600?random=${n}`,
          translation: translations[index] || `ç¬¬${n}æ®µè¶…é…·ç¿»è¯‘æ­£åœ¨åŠ è½½ä¸­...ğŸš€`,
          keyPoints: keyPointsList[index] || `ã€å­—è¯ã€‘æš‚æ— è€ƒç‚¹\nã€å¥å¼ã€‘æ•¬è¯·æœŸå¾…ï½`
        };
      });
    }

    function levenshteinDistance(a, b) {
      if (a.length === 0) return b.length;
      if (b.length === 0) return a.length;
      const matrix = Array(b.length + 1).fill().map((_, i) => [i]);
      for (let j = 0; j <= a.length; j++) matrix[0][j] = j;
      for (let i = 1; i <= b.length; i++) {
        for (let j = 1; j <= a.length; j++) {
          const cost = b[i-1] === a[j-1] ? 0 : 1;
          matrix[i][j] = Math.min(matrix[i-1][j] + 1, matrix[i][j-1] + 1, matrix[i-1][j-1] + cost);
        }
      }
      return matrix[b.length][a.length];
    }

    function highlightDifferences(spoken, original) {
      const cleanSpoken = spoken.replace(/[ï¼Œã€‚ï¼Ÿï¼ï¼›ï¼šâ€œâ€â€˜â€™\s]/g, '');
      const cleanOriginal = original.replace(/[ï¼Œã€‚ï¼Ÿï¼ï¼›ï¼šâ€œâ€â€˜â€™\s]/g, '');
      
      let result = '';
      let i = 0, j = 0;
      
      while (i < cleanSpoken.length || j < cleanOriginal.length) {
        if (i < cleanSpoken.length && j < cleanOriginal.length && cleanSpoken[i] === cleanOriginal[j]) {
          result += `<span class="highlight-correct">${cleanSpoken[i]}</span>`;
          i++; j++;
        } else if (i < cleanSpoken.length && (j >= cleanOriginal.length || !cleanOriginal.includes(cleanSpoken[i]))) {
          result += `<span class="highlight-extra">${cleanSpoken[i]}</span>`;
          i++;
        } else {
          result += `<span class="highlight-missing">${cleanOriginal[j]}</span>`;
          j++;
        }
      }
      return result || 'ï¼ˆæ— å†…å®¹ï¼‰';
    }

    function getColorByScore(score) {
      if (score >= 90) return '#27ae60';
      if (score >= 70) return '#f39c12';
      return '#e74c3c';
    }

    function advancedCompare(spoken, original) {
      const cleanSpoken = spoken.replace(/[ï¼Œã€‚ï¼Ÿï¼ï¼›ï¼šâ€œâ€â€˜â€™\s]/g, '');
      const cleanOriginal = original.replace(/[ï¼Œã€‚ï¼Ÿï¼ï¼›ï¼šâ€œâ€â€˜â€™\s]/g, '');

      const editDist = levenshteinDistance(cleanSpoken, cleanOriginal);
      const maxLength = Math.max(cleanSpoken.length, cleanOriginal.length);
      const accuracy = maxLength > 0 ? Math.max(0, 100 - Math.round((editDist / maxLength) * 100)) : 0;

      const originalWords = cleanOriginal.split('');
      const spokenSet = new Set(cleanSpoken.split(''));
      const covered = originalWords.filter(w => spokenSet.has(w)).length;
      const completeness = originalWords.length > 0 ? Math.round((covered / originalWords.length) * 100) : 0;

      const fluency = spoken.length > 5 ? Math.min(100, 80 + Math.random() * 20) : 50;

      const highlighted = highlightDifferences(spoken, original);

      return { accuracy, completeness, fluency, highlighted };
    }

    function renderFeedback(result, spoken) {
      const { accuracy, completeness, fluency, highlighted } = result;
      const avg = Math.round((accuracy + completeness + fluency) / 3);

      let comment = "";
      if (avg >= 90) comment = "ğŸŒŸ èƒŒå¾—å®Œç¾ï¼ä½ å°±æ˜¯å¤æ–‡å°è¾¾äººï¼";
      else if (avg >= 75) comment = "ğŸ‘ å¾ˆæ£’ï¼æ³¨æ„å‡ ä¸ªå­—å°±æ»¡åˆ†å•¦ï½";
      else if (avg >= 60) comment = "ğŸ’¡ æœ‰è¿›æ­¥ï¼å†è¯»ä¸¤éä¼šæ›´å¥½";
      else comment = "ğŸŒ± åˆ«ç°å¿ƒï¼Œå¤šå¬å¤šè¯»ï¼Œä½ ä¸€å®šè¡Œï¼";

      const feedbackHTML = `
        <h3>ğŸ“Š èƒŒè¯µè¯„æµ‹æŠ¥å‘Š</h3>
        <p><strong>ä½ è¯´çš„æ˜¯ï¼š</strong>${spoken}</p>
        <p><strong>åŸæ–‡å¯¹æ¯”ï¼š</strong></p>
        <div style="font-family:monospace; padding:8px; background:#eee; border-radius:4px;">${highlighted}</div>
        
        <div style="margin:15px 0;">
          <div>âœ… å‡†ç¡®ç‡: ${accuracy}%</div>
          <div class="score-bar"><div class="score-fill" style="width:${accuracy}%; background:${getColorByScore(accuracy)}"></div></div>
          
          <div>ğŸ“š å®Œæ•´åº¦: ${completeness}%</div>
          <div class="score-bar"><div class="score-fill" style="width:${completeness}%; background:${getColorByScore(completeness)}"></div></div>
          
          <div>ğŸ—£ï¸ æµç•…åº¦: ${fluency.toFixed(0)}%</div>
          <div class="score-bar"><div class="score-fill" style="width:${fluency}%; background:${getColorByScore(fluency)}"></div></div>
        </div>
        
        <p><strong>ç»¼åˆè¯„åˆ†: ${avg}åˆ†</strong></p>
        <p style="font-weight:bold; color:${avg>=80?'#27ae60':avg>=60?'#f39c12':'#e74c3c'}">${comment}</p>
      `;

      const el = document.getElementById('feedbackArea');
      el.innerHTML = feedbackHTML;
      el.style.display = 'block';
    }

    function updateBodyBackground(imageUrl) {
      document.body.style.backgroundImage = `url(${imageUrl})`;
    }

    // === ä¸»æµç¨‹ ===
    function updatePreview() {
      const selectVal = document.getElementById('poemSelect').value;
      const manualVal = document.getElementById('manualInput').value.trim();
      const previewArea = document.getElementById('previewArea');
      const previewText = document.getElementById('previewText');
      const confirmBtn = document.getElementById('confirmBtn');

      let textToShow = manualVal || selectVal;
      if (textToShow) {
        previewText.textContent = textToShow;
        previewArea.style.display = 'block';
        confirmBtn.disabled = false;
      } else {
        previewArea.style.display = 'none';
        confirmBtn.disabled = true;
      }
    }

    function confirmYuanwen() {
      const selectEl = document.getElementById('poemSelect');
      const title = selectEl.options[selectEl.selectedIndex].text;
      const finalText = document.getElementById('manualInput').value.trim() || selectEl.value;

      if (!finalText) return alert("è¯·å…ˆé€‰æ‹©æˆ–è¾“å…¥å¤æ–‡ï¼");
      
      window.yuanwen = finalText;
      const segments = autoSegment(finalText);
      window.m3Data = generatePlaceholderM3Data(segments);
      
      document.getElementById('backgroundText').textContent = `ã€åˆ›ä½œèƒŒæ™¯å ä½ã€‘\næ­£åœ¨å­¦ä¹ ï¼š${title}`;
      document.getElementById('backgroundPanel').style.display = 'block';
      document.getElementById('startReciteBtn').style.display = 'block';
    }

    function updateReciteSegment() {
      if (!window.m3Data || currentSegmentIndex < 0 || currentSegmentIndex >= window.m3Data.length) {
        console.warn("æ— æ•ˆæ®µè½ç´¢å¼•");
        return;
      }

      const data = window.m3Data[currentSegmentIndex];
      const total = window.m3Data.length;
      document.getElementById('currentIdx').textContent = currentSegmentIndex + 1;
      document.getElementById('totalSegs').textContent = total;

      updateBodyBackground(data.image);

      const viewMode = segmentStates[currentSegmentIndex]?.viewMode || null;
      const contentContainer = document.getElementById('contentContainer');
      
      if (viewMode === 'translation') {
        contentContainer.innerHTML = `<div style="margin:10px 0;"><strong>ğŸ’¬ è¯‘æ–‡ï¼š</strong><p>${data.translation}</p></div>`;
      } else if (viewMode === 'keyPoints') {
        contentContainer.innerHTML = `<div style="margin:10px 0;"><strong>ğŸ’¡ è€ƒç‚¹ï¼š</strong><pre>${data.keyPoints}</pre></div>`;
      } else {
        contentContainer.innerHTML = '';
      }

      // åŒæ­¥å•é€‰æŒ‰é’®çŠ¶æ€
      document.querySelectorAll('input[name="viewMode"]').forEach(radio => {
        radio.checked = (radio.value === viewMode);
      });

      document.getElementById('prevBtn').disabled = currentSegmentIndex === 0;
      document.getElementById('nextBtn').disabled = currentSegmentIndex === total - 1;
      
      document.getElementById('retryBtn').style.display = 'none';
      document.getElementById('feedbackArea').style.display = 'none';
      document.getElementById('speechInput').value = '';
    }

    function renderReciteInterface() {
      if (!window.m3Data || window.m3Data.length === 0) {
        alert("è¯·å…ˆç¡®è®¤åŸæ–‡ï¼");
        return;
      }

      ['poemSelect', 'manualInput', 'previewArea', 'confirmBtn', 'backgroundPanel', 'startReciteBtn']
        .forEach(id => {
          const el = document.getElementById(id);
          if (el) el.style.display = 'none';
        });
      const label = document.querySelector('label[for="manualInput"]');
      if (label) label.style.display = 'none';

      document.getElementById('reciteArea').style.display = 'block';
      currentSegmentIndex = 0;
      updateReciteSegment();
      
      setTimeout(() => {
        document.getElementById('reciteArea').scrollIntoView({ behavior: 'smooth', block: 'start' });
      }, 100);
    }

    // === äº‹ä»¶ç»‘å®š ===
    document.getElementById('poemSelect').addEventListener('change', updatePreview);
    document.getElementById('manualInput').addEventListener('input', updatePreview);
    document.getElementById('confirmBtn').addEventListener('click', confirmYuanwen);
    document.getElementById('startReciteBtn').addEventListener('click', renderReciteInterface);

    ['prevBtn', 'nextBtn'].forEach(btnId => {
      document.getElementById(btnId).addEventListener('click', () => {
        if (btnId === 'prevBtn' && currentSegmentIndex > 0) {
          currentSegmentIndex--;
        } else if (btnId === 'nextBtn' && currentSegmentIndex < window.m3Data.length - 1) {
          currentSegmentIndex++;
        }
        updateReciteSegment();
        document.getElementById('reciteArea').scrollIntoView({ behavior: 'smooth', block: 'start' });
      });
    });

    document.querySelectorAll('input[name="viewMode"]').forEach(radio => {
      radio.addEventListener('change', () => {
        if (!segmentStates[currentSegmentIndex]) {
          segmentStates[currentSegmentIndex] = {};
        }
        segmentStates[currentSegmentIndex].viewMode = radio.value;
        updateReciteSegment();
      });
    });

    document.getElementById('submitSpeechBtn').addEventListener('click', () => {
      const spoken = document.getElementById('speechInput').value.trim();
      if (!spoken) {
        alert("è¯·å…ˆé€šè¿‡é”®ç›˜ğŸ¤è¾“å…¥èƒŒè¯µå†…å®¹ï¼");
        return;
      }
      const original = window.m3Data[currentSegmentIndex].originalText;
      const result = advancedCompare(spoken, original);
      renderFeedback(result, spoken);

      document.getElementById('retryBtn').style.display = 'block';
      
      setTimeout(() => {
        document.getElementById('feedbackArea').scrollIntoView({ behavior: 'smooth', block: 'nearest' });
      }, 100);
    });

    document.getElementById('retryBtn').addEventListener('click', () => {
      document.getElementById('speechInput').value = '';
      document.getElementById('feedbackArea').style.display = 'none';
      document.getElementById('retryBtn').style.display = 'none';
      document.getElementById('speechInput').focus();
    });
  </script>
</body>
</html>